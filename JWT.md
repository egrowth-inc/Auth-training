# トークンベース認証(`JWT`    JSON Web Token)

## トークンベース動画

https://egrowth-my.sharepoint.com/:v:/g/personal/kitayama_egrowth-inc_com/EaOqXUQfnVZDlm2QoVOZ1W4BXdW1IDgzyeDynmvxabIRCw?e=d4Hext

## クライアントとサーバーの関係

![alt text](image-8.png)

具体的な例：ChatGPTを使った流れ

ユーザーがChatGPTのウェブサイトにアクセスし、質問を入力する。

1. 人間 → クライアント（ウェブブラウザ）
ウェブブラウザが質問内容をOpenAIのサーバーに送信する。

2. クライアント → サーバー
サーバーが質問を処理し、適切な回答を生成する。

3. サーバー（処理）
サーバーが生成した回答をウェブブラウザに返送する。

4. サーバー → クライアント
ウェブブラウザが回答をユーザーに表示する。

5. クライアント → 人間

## 概要

トークンベース認証では、ユーザーがログインするとサーバーはトークン（例: JWT）を生成し、それをクライアントに返します。
クライアントはそのトークンをローカルストレージやセッションストレージに保存し、以降のリクエスト時にトークンをヘッダーに含めて送信します。

## 用語解説

ローカルストレージ（Local Storage）:

- ユーザー設定の保存: テーマ設定、言語選択、フォントサイズなど、ユーザーが選んだ設定を保存する。
- キャッシュデータ: 頻繁にアクセスするデータを保存し、次回のアクセス時に素早く読み込む。
- オフラインデータ: インターネットに接続していないときでもアクセス可能なデータを保存する。

セッションストレージ（Session Storage）:

- 一時的なデータの保存: フォームの入力内容、一時的なユーザーの選択、ページ間でのデータの受け渡しなど。

- セッション情報の管理: ログイン状態や一時的な認証情報を保持する。

| 項目               | ローカルストレージ（Local Storage） | セッションストレージ（Session Storage） |
|--------------------|------------------------------------|----------------------------------------|
| データの持続性     | ブラウザを閉じても保持される       | ブラウザのタブやウィンドウを閉じると消える |
| 主な用途           | ユーザー設定、キャッシュ、オフラインデータ | 一時的なデータ、フォーム入力内容        |
| 共有性             | 同じドメイン内のすべてのタブで共有可能 | 同じタブ内でのみ有効                    |
| 容量制限           | 約5MB（ブラウザによる）             | 約5MB（ブラウザによる）                 |

## セッション認証との違い

##  1. 情報の保存場所

### セッション認証:

- サーバー側に保存: ユーザーのセッション情報（例：ユーザーID、ログイン状態など）はサーバー側に保存されます。

- クライアント側: クライアント（ブラウザ）はセッションIDをクッキーに保存し、リクエストごとにサーバーに送信します。

### トークン認証(JWT認証):

- トークン自体に情報を含む: JWTにはユーザー情報や認証情報が含まれており、サーバー側でセッションを保持する必要がありません。

- クライアント側に保存: クライアントはJWTをローカルストレージやクッキーに保存し、リクエストごとにトークンを送信します。

## 2. スケーラビリティ

### セッション認証:

- サーバー負荷: 各ユーザーのセッション情報をサーバーが管理するため、ユーザー数が増えるとサーバーの負荷が増大します。

- スケーリングの課題: 複数のサーバーで負荷分散を行う場合、セッション情報を共有する必要があります（例：共有セッションストアの利用）。

### トークン認証(JWT認証):

- サーバー負荷軽減: トークン自体に情報が含まれているため、サーバーはセッションを管理する必要がありません。

- スケーリングの容易さ: スケールアウト（サーバーの増設）が容易で、各サーバーが独立してトークンを検証できます。

#### セッション認証の流れ

1. ユーザーがログインフォームに入力して送信。
2. サーバーがユーザー情報を認証。
3. サーバーがセッションを作成し、セッションIDを生成。（ここから動きが変わってくる）
4. セッションIDをクライアントのクッキーに保存。
5. 以降のリクエストでクッキーのセッションIDをサーバーに送信。
6. サーバーがセッションIDを基にユーザーを認証。

#### JWT認証の流れ

1. ユーザーがログインフォームに入力して送信。
2. サーバーがユーザー情報を認証。
3. サーバーがJWTを生成し、クライアントに返却。
4. クライアントがJWTをローカルストレージやクッキーに保存。
5. 以降のリクエストでJWTをヘッダーに含めてサーバーに送信。
6. サーバーがJWTを検証し、ユーザーを認証。


## JWT（JSON Web Token）は、ユーザーの認証情報を含むコンパクトで自己完結型のトークンです。以下の3つの部分から構成されています：

- **ヘッダー（Header）** 

トークンのタイプ（通常はJWT）と署名に使用されるアルゴリズム（例: HMAC SHA256）

例：封筒の上部

- 封筒の上部に書かれた情報: 誰が送っているのか、どの方法で封筒が封印されているのか（例：手紙、書類、秘密のメッセージなど）。

- 役割: 受け取る側が封筒を開封する際に、どの方法で開封すればよいかを判断するための情報。

```php
{
    "alg": "HS256",
    "typ": "JWT"
}

```

- **ペイロード（Payload）**

トークンに含めるクレーム（ユーザー情報やトークンの有効期限など）

例：中身の手紙

- 手紙の内容: 送信者が伝えたい情報やメッセージ。
- 役割: 受け取る側が実際に読む内容。

```php
{
    "sub": "1234567890",
    "name": "John Doe",
    "iat": 1516239022,
    "exp": 1516242622
}
```

- **署名（Signature）**

ヘッダーとペイロードを秘密鍵で署名し、トークンの改ざんを防止

例：封印 

- 封筒の封印: 封印には特定のスタンプや署名が押されており、これにより封筒が開封されたかどうかを確認できます。

- 役割: 封筒が途中で開封されていないことを保証し、封印のスタンプが正当なものか確認できる。

```php

HMACSHA256(
    base64UrlEncode(header) + "." +
    base64UrlEncode(payload),
    secret
)
```

全体のトークン例

```php

Base64URLエンコードされたヘッダー.ペイロード.署名

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.(ヘッダー部分)eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.(ペイロード部分)SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c(シグネチャ部分)

```

## 仕組み:

1. 認証時にサーバーはユーザー情報を含むJWTを生成し、クライアントに送信します。

2. クライアントはこのトークンを保存し、以降のリクエストでヘッダーに含めて送信します。

3. サーバーは受け取ったトークンを検証し、ユーザーを認証します。

## APIDogを使いリクエストのテスト

https://jwt.io/  JWT公式サイトここでデコードできる

## 登録のリクエストの送信

エンドポイント：

```bash

POST http://localhost:8000/api/register

```

リクエストボディ:

```bash

{
    "name": "名前",
    "email": "好きなメールアドレス",
    "password": "password123",
    "password_confirmation": "password123"
}

```

期待されるレスポンス:

```bash

{
    "message": "ユーザー登録が成功しました。",
    "user": {
        "id": 1,
        "name": "名前",
        "email": "好きなメールアドレス",
        "created_at": "2024-04-27T12:00:00.000000Z",
        "updated_at": "2024-04-27T12:00:00.000000Z"
    },
    "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
}
```


## ログインリクエストの送信

エンドポイント: 

```bash
POST http://localhost:8000/api/login
```

リクエストボディ:

```bash
{
    "email": "名前",
    "password": "password123"
}

```

期待されるレスポンス:

```bash
{
    "message": "ログインに成功しました。",
    "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
}
```

## ログアウトリクエストの送信

エンドポイント:

```bash

 POST http://localhost:8000/api/logout

```

ヘッダー:

```bash
Authorization: Bearer {token}
```

期待されるレスポンス:

```bash
{
    "message": "ログアウトに成功しました。"
}
```

## JWT公式デコード内容意味

{
  "alg": "HS256",
  "typ": "JWT"
}

### 1. iss (Issuer)

- トークンを発行したサーバーやシステムを表す。

この場合、"http://localhost:8000/api/register" がトークンを発行したURL。
例: 「このトークンは http://localhost:8000/api/register で作られたよ！」という情報。

### 2. iat (Issued At)

トークンが発行された日時を表す（UNIXタイムスタンプ）。

値: 1732180573 → これは 2024年11月21日 09:16:13。
例: 「トークンはこの時間に発行されたよ！」という情報。

### 3. exp (Expiration Time)

トークンの有効期限を表す（UNIXタイムスタンプ）。

値: 1732184173 → これは 2024年11月21日 10:16:13（発行後1時間後）。
例: 「このトークンは 10:16:13 まで使えるよ！」という情報。

### 4. nbf (Not Before)

このトークンが有効になる開始時刻を表す（UNIXタイムスタンプ）。

値: 1732180573 → これは 2024年11月21日 09:16:13。
例: 「このトークンは 09:16:13 より前には使えないよ！」という情報。

### 5. jti (JWT ID)

トークンの一意の識別子（ID）。

値: "qdCEDiBZL91wwSnw"。
例: 「このトークンのIDは qdCEDiBZL91wwSnw だよ！」という情報。
使い道: トークンを特定して無効化する際などに使用。

### 6. sub (Subject)

トークンが対象としているユーザーやエンティティを表す。

値: "12" → おそらくユーザーID 12。
例: 「このトークンはユーザーID 12 のために作られたよ！」という情報。

### 7. prv (Private Claim)

カスタムデータを格納するためのフィールド。

値: "23bd5c8949f600adb39e701c400872db7a5976f7"。
例: アプリケーションで必要な特定の情報（例: トークンの暗号化キーや内部参照用データ）。



# Laravel JWT認証のフローとコードサンプル

## 1. register メソッド (ユーザー登録)

### 役割:
新しいユーザーを登録し、そのユーザーに対応するJWTトークンを発行する。

### 流れ:
#### 入力データのバリデーション
`name`, `email`, `password`を検証し、条件を満たさない場合はエラーを返す。

```php
$validatedData = $request->validate([
    'name' => 'required|string|max:255',
    'email' => 'required|string|email|max:255|unique:users',
    'password' => 'required|string|confirmed|min:8',
]);
```

#### ユーザー作成
バリデーション済みのデータを使って、新しいユーザーをデータベースに保存。

```php
$user = User::create([
    'name' => $validatedData['name'],
    'email' => $validatedData['email'],
    'password' => Hash::make($validatedData['password']),
]);
```

#### JWTトークンを生成
新しく作成されたユーザーを基にトークンを発行。

```php
$token = JWTAuth::fromUser($user);
```

#### レスポンスを返却
作成したユーザー情報とトークンをJSON形式で返す。

---

## 2. login メソッド (ログイン)

### 役割:
メールアドレスとパスワードを検証し、認証が成功すればJWTトークンを発行。

### 流れ:
#### 資格情報を取得
リクエストから`email`と`password`を取得。

```php
$credentials = $request->only('email', 'password');
```

#### JWTトークンを試行
入力された資格情報を基にログインを試みる。

- 成功: トークンを生成。
- 失敗: `401 Unauthorized` エラーを返却。

```php
if (!$token = JWTAuth::attempt($credentials)) {
    return response()->json(['error' => '無効な認証情報'], 401);
}
```

#### エラーハンドリング
トークン生成中に問題が発生した場合は`500 Internal Server Error`を返す。

#### レスポンスを返却
トークンをJSON形式で返す。

---

## 3. logout メソッド (ログアウト)

### 役割:
クライアントから送られたJWTトークンを無効化する。

### 流れ:
#### トークンの無効化
`JWTAuth::invalidate`を使って、現在のトークンを無効化。

```php
JWTAuth::invalidate(JWTAuth::getToken());
```

#### エラーハンドリング
トークン無効化中に問題が発生した場合は`500 Internal Server Error`を返す。

#### レスポンスを返却
ログアウト成功のメッセージをJSON形式で返す。

---

## 4. user メソッド (認証済みユーザー情報の取得)

### 役割:
現在ログイン中のユーザー情報を返却。

### 流れ:
#### 認証済みユーザーを取得
Laravelの`Auth::user()`を使って、現在認証中のユーザー情報を取得。

```php
return response()->json(Auth::user());
```

#### レスポンスを返却
認証されたユーザー情報をJSON形式で返す。

---

## JWTの役割と流れを整理

- **ユーザー登録時 (register):**
  - 新規ユーザーを登録し、トークンを発行。
  - トークンには「誰がログインしているか」「トークンの有効期限」などが含まれる。

- **ログイン時 (login):**
  - 資格情報を検証し、認証が成功すればトークンを発行。
  - トークンはクライアント側に保存される（例: ローカルストレージ）。

- **ログアウト時 (logout):**
  - トークンをサーバー側で無効化し、再利用を防ぐ。

- **ユーザー情報取得時 (user):**
  - トークンを検証し、認証済みユーザーの情報を取得。

---

## 補足: このコードの動作を確認するには

### 1. ルート設定
`routes/api.php` に以下を追加：

```php
use App\Http\Controllers\AuthController;

Route::post('/register', [AuthController::class, 'register']);
Route::post('/login', [AuthController::class, 'login']);
Route::post('/logout', [AuthController::class, 'logout'])->middleware('auth:api');
Route::get('/user', [AuthController::class, 'user'])->middleware('auth:api');
```

### 2. Postmanで動作確認
- **POST /register:** 新しいユーザー登録。
- **POST /login:** トークンを取得。
- **POST /logout:** トークンを無効化。
- **GET /user:** 認証されたユーザー情報を取得。


## 一言で言うと、

### JWT認証はクライアントが保持するトークンを使ってステートレスに認証を行う方式で、セッション認証はサーバーがセッション情報を管理するステートフルな方式です。

## 一番覚えるべきこと

### JWT認証はサーバーが状態を保持しないためスケーラビリティに優れており、分散システムやマイクロサービスに適しています。

### 一方、セッション認証はサーバー側でセッションを管理するため、セキュリティ管理が容易であり、小規模から中規模のアプリケーションに向いています。

